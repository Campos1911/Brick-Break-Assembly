     1                                  ; Este programa tem por objetivo usar a interrupção por hardware de "tique", a qual é definida como Int 8
     2                                  ; O sistema utiliza uma fonte de relogio de ~18.2 Hz, ou seja, a cada ~0.0549 segundos ou ~54.9 ms, o sistema é interrumpido
     3                                  
     4                                  segment code
     5                                  ..start:
     6 00000000 B8[0000]                		MOV 	AX,data						; Inicializa o registrador de Segmento de Dados DS
     7 00000003 8ED8                    		MOV 	DS,AX
     8 00000005 B8[0000]                		MOV 	AX,stack					; Inicializa o registrador de Segmento de Pilha SS
     9 00000008 8ED0                    		MOV 	ss,AX
    10 0000000A BC[0001]                		MOV 	sp,stacktop					; Inicializa o apontador de Pilha SP
    11                                  	
    12                                  		
    13                                  	
    14                                  escreveNum:
    15 0000000D FA                      		CLI								; Deshabilita INTerrupções por hardware - pin INTR NÃO atende INTerrupções externas	
    16 0000000E 31C0                            XOR     AX, AX					; Limpa o registrador AX, é equivalente a fazer "MOV AX,0"
    17 00000010 8EC0                            MOV     ES, AX					; Inicializa o registrador de Segmento Extra ES para acessar à região de vetores de INTerrupção (posição zero de memoria)
    18 00000012 26A12400                        MOV     AX, [ES:INT9*4]			; Carrega em AX o valor do IP do vector de INTerrupção 9 
    19 00000016 A3[0300]                        MOV     [offset_dos9], AX    	; Salva na variável offset_dos o valor do IP do vector de INTerrupção 9
    20 00000019 26A12600                        MOV     AX, [ES:INT9*4+2]   	; Carrega em AX o valor do CS do vector de INTerrupção 9
    21 0000001D A3[0100]                        MOV     [cs_dos9], AX			; Salva na variável cs_dos o valor do CS do vector de INTerrupção 9     
    22 00000020 268C0E2600                      MOV     [ES:INT9*4+2], CS		; Atualiza o valor do CS do vector de INTerrupção 9 com o CS do programa atual 
    23 00000025 26C7062400[9C01]                MOV     WORD [ES:INT9*4],keyINT	; Atualiza o valor do IP do vector de INTerrupção 9 com o offset "keyINT" do programa atual
    24 0000002C FB                              STI								; Habilita INTerrupções por hardware - pin INTR SIM atende INTerrupções externas
    25                                  
    26                                  L1:
    27 0000002D A1[2200]                        MOV     AX,[p_i]				; loop - se não tem tecla pulsada, não faz nada! p_i só é atualizado (p_i = p_i + 1) na Rotina de Serviço de INTerrupção (ISR) "keyINT" 
    28 00000030 3B06[2400]                      CMP     AX,[p_t]
    29 00000034 74F7                            JE      L1
    30 00000036 FF06[2400]                      INC     word[p_t]				; p_t - se atualiza (p_t = p_t + 1) só se p_i foi atualizado, ou seja, se teve tecla pulsada
    31 0000003A 8126[2400]0700                  AND     word[p_t],7				
    32 00000040 8B1E[2400]                      MOV     BX,[p_t]				; Carrega em BX o valor de p_t
    33 00000044 31C0                            XOR     AX, AX
    34 00000046 8A87[1A00]                      MOV     AL, [BX+tecla]			; Carrega em AL o valor da variável tecla (variável atualizada durante a ISR) mais o offset BX, AL <- [BX+tecla]  
    35 0000004A A2[1900]                        MOV     [tecla_u],al			; Transfere o valor de AL (no caso o valor da tecla - Código Make/Break) para variável "tecla_u"
    36                                          
    37 0000004D B310                    		MOV     BL, 16					; Como AL contem o valor do código Make da tecla pulsada ou código Break da tecla liverada carrega BL com 16
    38 0000004F F6F3                            DIV     BL						; para dividir por 16 e representar em Hexa o valor do código Make/Break - "Lembrar que Cociente fical em AL e residuo em AH"
    39 00000051 0430                            ADD     Al, 30h					; Acrecenta 0x30 a AL para converter em ascii, por exemplo se for Make = 1, o ascii de 1 é 0x31			
    40 00000053 3C3A                            CMP     AL, 3Ah                 ; Se a tecla pulsada for differente de número, ou seja, se for uma letra o valor é superior a 0x3A. Ver tabela ascii
    41                                  										; 
    42 00000055 7202                            JB      continua				; Se for numero de 0 até 9, daria 0x30 até 0x39, então pula para "continua"
    43 00000057 0407                            ADD     AL, 07h					; Se não for numero, acrescenta 7 para pular os carateres - ver tabela ascii
    44                                  
    45                                  continua:        
    46 00000059 A2[2600]                        MOV     [teclasc], AL			; O cociente da divisão é transferido à variável "teclasc"
    47 0000005C 80C430                          ADD     AH, 30h					; Repete o processo com o ressiduo: Acrescenta 0x30 para converter em ascii,
    48 0000005F 80FC3A                          CMP     AH, 3Ah					; Verifica se é maior do que 0x39, ou seja, se é letra!
    49 00000062 7203                            JB      continua1				; Se não, então é numero (0x30 até 0x39) e pula para "continua1"
    50 00000064 80C407                          ADD     AH, 07h					; Se não for numero, então é letra e acrescenta 7 para pular os carateres - ver tabela ascii
    51                                  
    52                                  continua1:
    53 00000067 8826[2700]                      MOV     [teclasc+1], AH			; O ressiduo da divisão é transferido à variável "teclasc+1"
    54                                  		
    55 0000006B 803E[1900]AF                    CMP     BYTE [tecla_u], 0XAF	; Se for pulsada a tecla D 
    56 00000070 740A                            JE      L2						; Ele pula para L2 e usa o modo 12 horas
    57 00000072 803E[1900]A0            		CMP BYTE [tecla_u], 0xA0		; Se vor selecionado V, ele usa o modo 24 horas
    58 00000077 741F                    		JE 		L3
    59 00000079 E9B1FF                          JMP     L1						; Se não, pula para L1 e começa tudo de novo!
    60                                  
    61                                  L2:										; Ao sair do programa temos que restaurar o CS:IP da INTerrupção 9, que incialmente alteramos nas linhas 26 e 27
    62 0000007C FA                              CLI								; Deshabilita INTerrupções por hardware - pin INTR NÃO atende INTerrupções externas
    63 0000007D 31C0                            XOR     AX, AX					; Limpa o registrador AX, é equivalente a fazer "MOV AX,0"				
    64 0000007F 8EC0                            MOV     ES, AX					; Inicializa o registrador de Segmento Extra ES para acessar à região de vetores de INTerrupção (posição zero de memoria)
    65 00000081 A1[0100]                        MOV     AX, [cs_dos9]			; Carrega em AX o valor do CS do vector de INTerrupção 9 que foi salvo na variável cs_dos -> linha 25
    66 00000084 26A32600                        MOV     [ES:INT9*4+2], AX		; Atualiza o valor do CS do vector de INTerrupção 9 que foi salvo na variável cs_dos
    67 00000088 A1[0300]                        MOV     AX, [offset_dos9]		; Carrega em AX o valor do IP do vector de INTerrupção 9 que foi salvo na variável offset_dos -> linha 23
    68 0000008B 26A32400                        MOV     [ES:INT9*4], AX 		; Atualiza o valor do IP do vector de INTerrupção 9 que foi salvo na variável offset_dos
    69 0000008F B80C00                  		MOV		AX, 12
    70 00000092 A3[1800]                		MOV		[mode], AX
    71 00000095 E91C00                  		JMP 	lerNum
    72                                  
    73                                  L3:
    74 00000098 FA                      	CLI								; Deshabilita INTerrupções por hardware - pin INTR NÃO atende INTerrupções externas
    75 00000099 31C0                    	XOR     AX, AX					; Limpa o registrador AX, é equivalente a fazer "MOV AX,0"				
    76 0000009B 8EC0                    	MOV     ES, AX					; Inicializa o registrador de Segmento Extra ES para acessar à região de vetores de INTerrupção (posição zero de memoria)
    77 0000009D A1[0100]                	MOV     AX, [cs_dos9]			; Carrega em AX o valor do CS do vector de INTerrupção 9 que foi salvo na variável cs_dos -> linha 25
    78 000000A0 26A32600                	MOV     [ES:INT9*4+2], AX		; Atualiza o valor do CS do vector de INTerrupção 9 que foi salvo na variável cs_dos
    79 000000A4 A1[0300]                	MOV     AX, [offset_dos9]		; Carrega em AX o valor do IP do vector de INTerrupção 9 que foi salvo na variável offset_dos -> linha 23
    80 000000A7 26A32400                	MOV     [ES:INT9*4], AX 		; Atualiza o valor do IP do vector de INTerrupção 9 que foi salvo na variável offset_dos
    81 000000AB B81800                  	MOV		AX, 24
    82 000000AE A3[1800]                	MOV		[mode], AX
    83 000000B1 E90000                  	JMP 	lerNum
    84                                  
    85                                  
    86                                  lerNum:
    87 000000B4 31C0                    		XOR 	AX, AX						; Limpa o registrador AX, é equivALente a fazer "MOV AX,0"
    88 000000B6 8EC0                    		MOV 	ES, AX						; Inicializa o registrador de Segmento Extra ES para acessar à região de vetores de INTerrupção (posição zero de memoria)
    89 000000B8 26A12000                		MOV     AX, [ES:INTr*4]				; Carrega em AX o vALor do IP do vector de INTerrupção 8
    90 000000BC A3[0500]                		MOV     [offset_dos], AX    		; Salva na variável offset_dos o vALor do IP do vector de INTerrupção 8
    91 000000BF 26A12200                		MOV     AX, [ES:INTr*4+2]   		; Carrega em AX o vALor do CS do vector de INTerrupção 8
    92 000000C3 A3[0700]                		MOV     [cs_dos], AX  				; Salva na variável cs_dos o vALor do CS do vector de INTerrupção 8   
    93 000000C6 268C0E2200              		MOV     [ES:INTr*4+2], CS			; Atualiza o valor do CS do vector de INTerrupção 8 com o CS do programa atuAL
    94 000000CB 26C7062000[FF00]        		MOV     WORD [ES:INTr*4],ClockINT	; Atualiza o valor do IP do vector de INTerrupção 8 com o offset "ClockINT" do programa atuAL
    95 000000D2 FB                      		STI									; Habilita INTerrupções por harDWare - pin INTR SIM atende INTerrupções externas
    96                                  
    97                                  
    98                                  volta:											; No loop principal l1, a função converte só é chamada se a variável tique for iguAL a 0, se não, verifica se ALguma tecla foi acionada para sair do programa
    99 000000D3 803E[0900]00            		CMP 	byte [tique], 0				; Compara variável tique com zero
   100 000000D8 7503                    		JNE 	ab							; Pula a ab se tique for diferente de zero	
   101 000000DA E87300                  		CALL 	converte					; Chama função converte se ab for iguAL a zero
   102                                  
   103                                  ab:
   104 000000DD B40B                    		MOV 	AH,0Bh						; Carrega em AH o valor de 0Bh, parâmetro para ler o teclado com interrupção por software "INT 21h"	
   105 000000DF CD21                    		INT 	21h							; Le buffer de teclado e armazena em AL "0" se nehuma tecla foi acionada ou "1" se qualquer tecla foi acionada
   106 000000E1 3C00                    		CMP 	AL,0						; Se o buffer está vacio, ou seja, nehuma tecla foi acionada pula para "l1", se não, pula para "fim"
   107 000000E3 7503                    		JNE 	fim							; Salto condicional -> se o teclado foi acionado pula para "fim"	
   108 000000E5 E9EBFF                  		JMP 	volta							; Salta para l1 se nehuma tecla foi acionada, ou seja, se a clausula do salto condicionla "linha 31" não foi acionada
   109                                  
   110                                  fim:										; Ao sair do programa temos que restaurar o CS:IP da Interrupção 8, que INCialmente alteramos nas linhas 19 e 20
   111 000000E8 FA                      		CLI									; Deshabilita Interrupções por harDWare - pin INTR NÃO atende Interrupções externas							
   112 000000E9 31C0                    		XOR     AX, AX						; Limpa o registrador AX, é equivalente a fazer "MOV AX,0"
   113 000000EB 8EC0                    		MOV     ES, AX						; Inicializa o registrador de Segmento Extra ES para acessar à região de vetores de INTerrupção (posição zero de memoria)
   114 000000ED A1[0700]                		MOV     AX, [cs_dos]				; Carrega em AX o valor do CS do vector de INTerrupção 8 que foi salvo na variável cs_dos -> linha 16
   115 000000F0 26A32200                		MOV     [ES:INTr*4+2], AX			; Atualiza o valor do CS do vector de INTerrupção 8 que foi salvo na variável cs_dos
   116 000000F4 A1[0500]                		MOV     AX, [offset_dos]			; Carrega em AX o valor do IP do vector de INTerrupção 8 que foi salvo na variável offset_dos				
   117 000000F7 26A32000                		MOV     [ES:INTr*4], AX 			; Atualiza o valor do IP do vector de INTerrupção 8 que foi salvo na variável offset_dos
   118 000000FB B44C                    		MOV     AH, 4Ch						; Carrega em AH o valor de 4Ch, parametro para INT 21h
   119 000000FD CD21                    		INT     21h							; Chama Interrupção 21h para RETornar o controle ao sistema operacional -> sai de forma segura da execução do programa
   120                                  
   121                                  ClockINT:									; Este segmento de código só será executado se um pulso de relojio está ativo, ou seja, se a INT 8h for acionada!
   122 000000FF 50                      		PUSH	AX							; Salva contexto na pilha							
   123 00000100 1E                      		PUSH	DS
   124 00000101 B8[0000]                		MOV     AX,data						; Carrega em AX o endereço de "data" -> Região do código onde encontra-se o segemeto de dados "Segment data"
   125 00000104 8ED8                    		MOV     DS,AX						; Atualiza registrador de segmento de dados DS, isso pode ser feito no inicio do programa!	
   126                                      
   127 00000106 FE06[0900]              		INC		byte [tique]				; Incremente variável tique toda vez que entra na interrupção
   128 0000010A 803E[0900]12            		CMP		byte[tique], 18				; Compara variável "teique" com 18, isso para alterar os valores do relogio a cada segundo -> 18/18.2 ~1 segundo!
   129 0000010F 7238                    		JB		Fimrel						; Se for menor que 18 pula para Fimrel
   130 00000111 C606[0900]00            		MOV 	byte [tique], 0				; Se não, limpa variável tique e  
   131 00000116 FE06[0A00]              		INC 	byte [segundo]				; Incrementa variável segundo
   132 0000011A 803E[0A00]3C            		CMP 	byte [segundo], 60			; Compara variável "segundo" com 60
   133 0000011F 7228                    		JB   	Fimrel						; Se segundo for menor do que 60, pula para Fimrel
   134 00000121 C606[0A00]00            		MOV 	byte [segundo], 0			; Se não, limpa segundo e
   135 00000126 FE06[0B00]              		INC 	byte [minuto]				; Incrementa variável minuto
   136 0000012A 803E[0B00]3C            		CMP 	byte [minuto], 60			; Compara variável "minuto" com 60
   137 0000012F 7218                    		JB   	Fimrel						; Se minuto for menor do que 60, pula para Fimrel
   138 00000131 C606[0B00]00            		MOV 	byte [minuto], 0			; Se não, limpa minuto e
   139 00000136 FE06[0C00]              		INC 	byte [hora]					; Incrementa variável hora
   140 0000013A 8A26[1800]              		MOV		AH, byte[mode]
   141 0000013E 3826[0C00]              		CMP 	byte [hora], AH				; Compara variável "hora" com 24
   142 00000142 7205                    		JB   	Fimrel						; Se hora for menor do que 24, pula para Fimrel
   143 00000144 C606[0C00]00            		MOV 	byte [hora], 0				; Se não, limpa hora	
   144                                  Fimrel:
   145 00000149 B020                    		MOV		AL,eoi						; Carrega o AL com a byte de End of Interruption, -> 20h por default						
   146 0000014B E620                    		OUT		20h,AL						; Livera o PIC que está na porta 20h
   147 0000014D 1F                      		POP		DS							; Reestablece os registradores salvos na pilha na linha 46
   148 0000014E 58                      		POP		AX
   149 0000014F CF                      		IRET								; Retorna da interrupção
   150                                  		
   151                                  converte:									; Esta função conver os valores binarios/decimais para ascii, ou seja acrecenta 0x30 a cada numero
   152 00000150 50                      		PUSH 	AX							; Salva contexto na pilha
   153 00000151 1E                      		PUSH    DS
   154 00000152 B8[0000]                		MOV     AX, data					; Carrega em AX o endereço de "data" -> Região do código onde encontra-se o segemeto de dados "Segment data"
   155 00000155 8ED8                    		MOV     DS, AX						; Atualiza registrador de segmento de dados DS, isso pode ser feito no inicio do programa!
   156                                  		
   157 00000157 30E4                    		XOR 	AH, AH						; Limpa AH, pois será utilizado na operação de divisão 
   158 00000159 B30A                    		MOV     BL, 10						; Carrega o operando da divisão
   159 0000015B A0[0A00]                		MOV 	AL, byte [segundo]			; Carrega em AL o valor da variável segundo de 0 até 59
   160 0000015E F6F3                    		DIV     BL							; Divide AL por BL, ou seja, AL/10. Como 10 é um byte, o cociente fica armacenado em AL e o residuo em AH 
   161 00000160 0430                    		ADD     AL, 30h 					; Acrecenta 0x30 ao cociente para converter em ascii                                                                                          
   162 00000162 A2[1300]                		MOV     byte [horario+6], AL		; Atualiza a variável "horario" ná posição decenas de segundos
   163 00000165 80C430                  		ADD     AH, 30h						; Acrecenta 0x30 ao residuo para converter em ascii
   164 00000168 8826[1400]              		MOV 	byte [horario+7], AH		; Atualiza a variável "horario" ná posição unidades de segundos
   165                                  											
   166 0000016C 30E4                    		XOR 	AH, AH						; Repete o processo anterior para minutos
   167 0000016E A0[0B00]                		MOV 	AL, byte [minuto]
   168 00000171 F6F3                    		DIV     BL
   169 00000173 0430                    		ADD     AL, 30h                                                                                          
   170 00000175 A2[1000]                		MOV     byte [horario+3], AL
   171 00000178 80C430                  		ADD     AH, 30h
   172 0000017B 8826[1100]              		MOV 	byte [horario+4], AH
   173                                  	
   174 0000017F 30E4                    		XOR 	AH, AH						; Repete o processo anterior para horas
   175 00000181 A0[0C00]                		MOV 	AL, byte [hora]
   176 00000184 F6F3                    		DIV     BL
   177 00000186 0430                    		ADD     AL, 30h                                                                                          
   178 00000188 A2[0D00]                		MOV     byte [horario], AL
   179 0000018B 80C430                  		ADD     AH, 30h
   180 0000018E 8826[0E00]              		MOV 	byte [horario+1], AH
   181                                  		
   182 00000192 B409                    		MOV 	AH, 09h						; Imprime o valor de horario com a interrupção 21h
   183 00000194 BA[0D00]                		MOV 	dx, horario
   184 00000197 CD21                    		INT 	21h
   185                                  		
   186 00000199 1F                      		POP     DS							; Recupera contexto salvo nas linhas 75 e 76
   187 0000019A 58                      		POP     AX
   188 0000019B C3                      		RET 								; Retorna da função 
   189                                  
   190                                  keyINT:									; Este segmento de código só será executado se uma tecla for presionada, ou seja, se a INT 9h for acionada!
   191 0000019C 50                              PUSH    AX						; Salva contexto na pilha
   192 0000019D 53                              PUSH    BX
   193 0000019E 1E                              PUSH    DS
   194 0000019F B8[0000]                        MOV     AX,data					; Carrega em AX o endereço de "data" -> Região do código onde encontra-se o segemeto de dados "Segment data" 			
   195 000001A2 8ED8                            MOV     DS,AX					; Atualiza registrador de segmento de dados DS, isso pode ser feito no inicio do programa!
   196 000001A4 E460                            IN      AL, kb_data				; Le a porta 60h, que é onde está o byte do Make/Break da tecla. Esse valor é fornecido pelo chip "8255 PPI"
   197 000001A6 FF06[2200]                      INC     WORD [p_i]				; Incrementa p_i para indicar no loop principal que uma tecla foi acionada!
   198 000001AA 8126[2200]0700                  AND     WORD [p_i],7			
   199 000001B0 8B1E[2200]                      MOV     BX,[p_i]				; Carrega p_i em BX
   200 000001B4 8887[1A00]                      MOV     [BX+tecla],al			; Transfere o valor Make/Break da tecla armacenado em AL "linha 84" para o segmento de dados com offset DX, na variável "tecla"
   201 000001B8 E461                            IN      AL, kb_ctl				; Le porta 61h, pois o bit mais significativo "bit 7" 
   202 000001BA 0C80                            OR      AL, 80h					; Faz operação lógica OR com o bit mais significativo do registrador AL (1XXXXXXX) -> Valor lido da porta 61h 
   203 000001BC E661                            OUT     kb_ctl, AL				; Seta o bit mais significativo da porta 61h
   204 000001BE 247F                            AND     AL, 7Fh					; Restablece o valor do bit mais significativo do registrador AL (0XXXXXXX), alterado na linha 90 	
   205 000001C0 E661                            OUT     kb_ctl, AL				; Reinicia o registrador de dislocamento 74LS322 e Livera a interrupção "CLR do flip-flop 7474". O 8255 - Programmable Peripheral Interface (PPI) fica pronto para recever um outro có
   206 000001C2 B020                            MOV     AL, eoi					; Carrega o AL com a byte de End of Interruption, -> 20h por default
   207 000001C4 E620                            OUT     pictrl, AL				; Livera o PIC
   208                                  		
   209 000001C6 1F                      		POP     DS						; Reestablece os registradores salvos na linha 79 
   210 000001C7 5B                              POP     BX
   211 000001C8 58                              POP     AX
   212 000001C9 CF                              IRET							; Retorna da interrupção
   213                                  
   214                                  segment data
   215                                  		kb_data 	EQU 60h  				; PORTA DE LEITURA DE TECLADO
   216                                          kb_ctl  	EQU 61h  				; PORTA DE RESET PARA PEDIR NOVA INTERRUPCAO
   217                                          pictrl  	EQU 20h					; PORTA DO PIC DE TECLADO
   218                                  		eoi     	EQU 20h					; Byte de final de interrupção PIC - resgistrador OCW2 do 8259A
   219                                  		INTr	   	EQU 08h					; Interrupção por hardware do tick
   220                                  		INT9    	EQU 09h
   221 00000000 00                      		char		DB	0
   222 00000001 0100                    		cs_dos9  	DW  1					; Variável de 2 bytes para armacenar o CS da INT 9
   223 00000003 0100                            offset_dos9 DW	1					; Variável de 2 bytes para armacenar o IP da INT 9
   224 00000005 0000                    		offset_dos	DW	0					; Variável de 2 bytes para armacenar o IP da INT 8
   225 00000007 0000                    		cs_dos		DW	0					; Variável de 2 bytes para armacenar o CS da INT 8
   226 00000009 00                      		tique		DB  0					; Variável de 2 bytes que é incrementada a cada tick do clock ~54.9 ms 
   227 0000000A 00                      		segundo		DB  0					; Variável para os segundos
   228 0000000B 00                      		minuto 		DB  0					; Variável para os minutos
   229 0000000C 00                      		hora 		DB  0					; Variável para as horas
   230 0000000D 00003A00003A000020-     		horario		DB  0,0,':',0,0,':',0,0,' ', 13,'$' ; Variável typo string para printar o relogio
   231 00000016 0D24               
   232 00000018 00                      		mode		DB  0
   233 00000019 00                      		tecla_u db 0
   234 0000001A <res 00000008>                  tecla   resb  8					; Variável de 8 bytes para armacenar a tecla presionada. Só precisa de 2 bytes!	 
   235 00000022 0000                            p_i     dw  0   				; Indice p/ Interrupcao (Incrementa na ISR quando pressiona/solta qualquer tecla)  
   236 00000024 0000                            p_t     dw  0   				; Indice p/ Interrupcao (Incrementa após retornar da ISR quando pressiona/solta qualquer tecla)    
   237 00000026 00000D0A24                      teclasc DB  0,0,13,10,'$'		; Variável tipo char para printar o código Make/Break em hexadecimal
   238                                  
   239                                  segment stack stack							; Segmento da pilha -> SS
   240 00000000 <res 00000100>          		resb 256							; Reserva 256 bytes para a pilha
   241                                  stacktop:									; Define ponteiro do topo da pilha -> SP
